(window.webpackJsonp=window.webpackJsonp||[]).push([[7],{352:function(n,s,t){"use strict";t.r(s);var a=t(42),e=Object(a.a)({},(function(){var n=this,s=n.$createElement,t=n._self._c||s;return t("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[t("h2",{attrs:{id:"_1-输入url到浏览器显示页面过程中都发生了什么？"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-输入url到浏览器显示页面过程中都发生了什么？"}},[n._v("#")]),n._v(" 1.输入URL到浏览器显示页面过程中都发生了什么？")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v("1.通过DNS解析域名的实际IP地址   \n\n   发送至 DNS 服务器并获得域名对应的 WEB 服务器的 ip 地址\n   DNS解析首先会从浏览器的缓存中去寻找是否有对应这个网址的IP地址\n   如果没有就去电脑系统的DNS缓存中去寻找（hosts文件）\n   如果没有就去路由器的DNS缓存中去寻找\n   如果没有就去ISP网络运营商的DNS缓存中去寻找\n   浏览器-> 电脑系统 -> 路由器 -> ISP网络运营商 -> 同时缓存\n\n3.浏览器建立一条与目标web服务器的TCP链接 三次握手\n\n  客户端向服务器发送一条建立连接的请求\n  服务器接受到请求之后给予回应\n  客户端接到回应之后再次向服务端发送了确认信号 双方至此建立的了连接\n\n4.浏览器向服务器发送一条HTTP请求报文\n\n5.服务器向浏览器返回一条HTTP响应报文\n\n6.关闭链接，浏览器开始解析文档\n\n7.首先根据获取到的HTML文件解析出DOM Tree\n\n8.进行css解析，生成Style Rules（css规则）\n\n9.执行js代码，遇到script标签的时候会立即解析脚本停止解析文档（因为js可能会改动DOM和CSS，所以把script标签放在最下方）\n如果script脚本是外部的，会等待脚本下载完毕，再继续解析文档（可以在script标签上增加属性defer会async优化\n加载速度）脚本解析完会将脚本中改变COM和CSS的地方分别解析出来，追加到DOM Tree和Style Rules上\n\n10.将DOM Tree与Style Rules合并成为Render Tree（渲染树）\n\n11.接着进入布局阶段，为每一个节点分配一个在页面中对应的坐标\n\n12.随后进行页面的绘制，遍历Render Tree的节点，将页面元素呈现出来\n")])])]),t("h2",{attrs:{id:"_2-浏览器的回流与重绘"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-浏览器的回流与重绘"}},[n._v("#")]),n._v(" 2.浏览器的回流与重绘")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v("1.回流必将引起重绘，重绘不一定会引起回流\n\n2.当Render Tree中部分或者全部元素的尺寸、结构或者某些属性发生改变时，浏览器重新渲染的或者称为回流\n    引起回流的操作：\n      页面首次渲染\n      浏览器窗口大小发生改变\n      元素尺寸或者位置发生改变\n      元素内容发生改变（文字数量，字体大小）\n      添加或者删除可见的DOM元素\n      激活css伪类(例如:hober :active)\n\n3.当页面中元素样式的改变并不影响刀它在文档流中的位置时，浏览器会将新样式赋予元素并重新绘制它，这个过程称为重绘     \n    引起重绘的操作：\n      字体颜色\n      背景颜色\n      \n回流和重绘的代价是很高的，首先会破环用户体验，比如渲染页面速度会相对迟缓，相比之下回流的影响更大\n\n   优化：\n     避免使用table布局\n     经可能在DOM的最末端改变class\n     避免使用css表达式（calc（））\n     js避免重复操作样式，最好一次性重写style或者将样式定义为class一次性更改\n     使用DocumentFragment，创建一个游离于DOM树之外的节点，然后在此节点上批量操作，最后插入DOM树中，因此只触发一次回流\n")])])]),t("h2",{attrs:{id:"_3-dom事件流"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-dom事件流"}},[n._v("#")]),n._v(" 3.DOM事件流")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v("事件捕获阶段-处于目标阶段和事件冒泡阶段\n捕获是从上到下  冒泡是从下往上\n\nDOM事件捕获得具体流程\nwindow -> document -> html -> body -> div \n事件冒泡阶段\n与事件捕获相反\n")])])]),t("h2",{attrs:{id:"_4-event对象得常见应用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-event对象得常见应用"}},[n._v("#")]),n._v(" 4.Event对象得常见应用")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v("1. event.preventDefault() \n\n   阻止默认事件。比如a得点击事件，form标签得submit事件。可以使用此方法来阻止默认事件\n   \n2. event.stopPropagation()\n\n   阻止事件冒泡，如果给父元素和子元素都加上事件得话，就需要阻止冒泡了，不然，子元素得事件会执行两次  \n\n3. event.stopImmediatePropagation()\n\n  阻止事件冒泡并且阻止相同事件的其他侦听器被调用。\n  如果有多个相同类型事件的事件监听函数绑定到同一个元素，当该类型的事件触发时，它们会按照被添加的顺序执行。如果其中某个监听函数执行了 event.stopImmediatePropagation() 方法，则当前元素剩下的监听函数将不会被执行。\n\n4. event.currentTarget   \n   \n   指向事件绑定的元素\n\n5. event.target\n   \n   触发事件的对象 (某个DOM元素) 的引用.可以用来实现事件委托 (event delegation)。\n")])])]),t("h2",{attrs:{id:"_5-reaact渲染dom的过程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-reaact渲染dom的过程"}},[n._v("#")]),n._v(" 5.reaact渲染DOM的过程")]),n._v(" "),t("div",{staticClass:"language-html line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-html"}},[t("code",[n._v("1. state数据\n       this.state = {\n         content:'item'\n        }\n        \n2. JSX模板\n   \n        rander(\n          "),t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("<")]),n._v("div")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(">")])]),n._v(" "),t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("<")]),n._v("span")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(">")])]),n._v("{this.state.content}"),t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("</")]),n._v("span")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(">")])]),n._v(" "),t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("<")]),n._v("div")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(">")])]),n._v("\n        )   \n\n3. JSX模板转化为createElement函数\n  \n    React.createElement('div',{},React,createElement('span',{},this.state.content))  \n    \n4.  再由createElement函数生成虚拟DOM，所谓虚拟DOM就是一个JS对象，来描述真实DOM\n    \n    {\n     type:'div',\n     props:{},\n     children:{\n       type:'span',\n       props:{},\n       children:'item'\n      }\n    }\n    \n5. 由虚拟DOM生成真实DOM，\n    \n    "),t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("<")]),n._v("div")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(">")])]),n._v(" "),t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("<")]),n._v("span")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(">")])]),n._v(" item "),t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("</")]),n._v("span")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(">")])]),n._v(" "),t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("</")]),n._v("div")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(">")])]),n._v("\n    \n6. state数据发生变化 setState异步改变数据\n    \n7. 重复2.3.4步生成新的虚拟DOM，和原始的虚拟DOM进行比较,找出改变的部分。（同层比对）\n      \n      利用diff算法同层比对新旧虚拟DOM 如果第n层就发现不同的时候，就会停止比较（就算下面n层下的DOM结构一致），虽然有些渲染DOM\n      上的浪费，但是大大提升两个虚拟DOM比较算法的速度。 \n      \n      如果给虚拟DOM节点加上key值得话，diff算法会比较得更加高效迅速，不建议用index作为key值，因为一旦发生删除或者插入，当前得节点虽然发生变化但是key值可能不会变，可能导致渲染内容缺失。key值最好是独一无二得。\n     \n8. 操作DOM，渲染被改变的部分 ..\n")])]),n._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[n._v("1")]),t("br"),t("span",{staticClass:"line-number"},[n._v("2")]),t("br"),t("span",{staticClass:"line-number"},[n._v("3")]),t("br"),t("span",{staticClass:"line-number"},[n._v("4")]),t("br"),t("span",{staticClass:"line-number"},[n._v("5")]),t("br"),t("span",{staticClass:"line-number"},[n._v("6")]),t("br"),t("span",{staticClass:"line-number"},[n._v("7")]),t("br"),t("span",{staticClass:"line-number"},[n._v("8")]),t("br"),t("span",{staticClass:"line-number"},[n._v("9")]),t("br"),t("span",{staticClass:"line-number"},[n._v("10")]),t("br"),t("span",{staticClass:"line-number"},[n._v("11")]),t("br"),t("span",{staticClass:"line-number"},[n._v("12")]),t("br"),t("span",{staticClass:"line-number"},[n._v("13")]),t("br"),t("span",{staticClass:"line-number"},[n._v("14")]),t("br"),t("span",{staticClass:"line-number"},[n._v("15")]),t("br"),t("span",{staticClass:"line-number"},[n._v("16")]),t("br"),t("span",{staticClass:"line-number"},[n._v("17")]),t("br"),t("span",{staticClass:"line-number"},[n._v("18")]),t("br"),t("span",{staticClass:"line-number"},[n._v("19")]),t("br"),t("span",{staticClass:"line-number"},[n._v("20")]),t("br"),t("span",{staticClass:"line-number"},[n._v("21")]),t("br"),t("span",{staticClass:"line-number"},[n._v("22")]),t("br"),t("span",{staticClass:"line-number"},[n._v("23")]),t("br"),t("span",{staticClass:"line-number"},[n._v("24")]),t("br"),t("span",{staticClass:"line-number"},[n._v("25")]),t("br"),t("span",{staticClass:"line-number"},[n._v("26")]),t("br"),t("span",{staticClass:"line-number"},[n._v("27")]),t("br"),t("span",{staticClass:"line-number"},[n._v("28")]),t("br"),t("span",{staticClass:"line-number"},[n._v("29")]),t("br"),t("span",{staticClass:"line-number"},[n._v("30")]),t("br"),t("span",{staticClass:"line-number"},[n._v("31")]),t("br"),t("span",{staticClass:"line-number"},[n._v("32")]),t("br"),t("span",{staticClass:"line-number"},[n._v("33")]),t("br"),t("span",{staticClass:"line-number"},[n._v("34")]),t("br"),t("span",{staticClass:"line-number"},[n._v("35")]),t("br"),t("span",{staticClass:"line-number"},[n._v("36")]),t("br"),t("span",{staticClass:"line-number"},[n._v("37")]),t("br"),t("span",{staticClass:"line-number"},[n._v("38")]),t("br"),t("span",{staticClass:"line-number"},[n._v("39")]),t("br"),t("span",{staticClass:"line-number"},[n._v("40")]),t("br"),t("span",{staticClass:"line-number"},[n._v("41")]),t("br")])])])}),[],!1,null,null,null);s.default=e.exports}}]);